#[cfg(test)]
mod mir_tests {
    use crate::analyzer::SemanticAnalyzer;
    use crate::lexar::lexer::lex;
    use crate::mir::builder::MirBuilder;
    use crate::parser::Parser;

    fn build_mir(input: &str) -> Result<MirBuilder, String> {
        let tokens = lex(input);
        let mut parser = Parser::new(&tokens);
        let result = parser.parse_program();

        match result {
            Ok(mut ast) => {
                let mut analyzer = SemanticAnalyzer::new(None);
                if let crate::parser::ast::AstNode::Program(ref mut nodes) = ast {
                    analyzer
                        .analyze_program(nodes)
                        .map_err(|e| format!("{:?}", e))?;

                    let mut mir_builder = MirBuilder::new();
                    mir_builder.build_program(nodes);
                    mir_builder.finalize();
                    Ok(mir_builder)
                } else {
                    Err("Not a program".to_string())
                }
            }
            Err(e) => Err(format!("Parse error: {:?}", e)),
        }
    }

    // =====================
    // Function Declarations
    // =====================
    #[test]
    fn test_simple_function_mir() {
        let input = r#"
            fn main() {
                let x = 42;
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
        let mir = result.unwrap();
        assert!(mir.program.functions.iter().any(|f| f.name == "main"));
    }

    #[test]
    fn test_function_with_params_mir() {
        let input = r#"
            fn add(x: Int, y: Int) -> Int {
                return x + y;
            }
            fn main() { }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
        let mir = result.unwrap();
        let add_fn = mir
            .program
            .functions
            .iter()
            .find(|f| f.name == "add")
            .unwrap();
        assert_eq!(add_fn.params.len(), 2);
    }

    #[test]
    fn test_mir_for_function_call() {
        let input = r#"
            fn foo(x: Int) -> Int { return x + 1; }
            fn main() {
                let y = foo(10);
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_recursive_function() {
        let input = r#"
            fn fact(n: Int) -> Int {
                if n <= 1 { return 1; }
                return n * fact(n-1);
            }
            fn main() {
                let x = fact(5);
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    // =====================
    // Stress Test: Many Function Definitions (doolang syntax generated by Rust)
    // This test checks that the compiler can handle a large number of function definitions.
    // The generated code is valid doolang: fn f0() {} fn f1() {} ... fn main() {}
    // It does NOT test function calls or usage.
    // =====================
    #[test]
    fn test_mir_for_many_functions() {
        let mut input = String::new();
        for i in 0..50 {
            input.push_str(&format!("fn f{}() {{}} ", i));
        }
        input.push_str("fn main() {}");
        let result = build_mir(&input);
        assert!(result.is_ok());
    }

    // =====================
    // Variable Declarations & Assignment
    // =====================
    #[test]
    fn test_mir_for_variable_assignment() {
        let input = r#"
            fn main() {
                let x = 1;
                let y = 2;
                let z = x + y;
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
        let mir = result.unwrap();
        assert!(mir.program.functions.iter().any(|f| f.name == "main"));
    }

    // =====================
    // Stress Test: Many Variable Declarations (doolang syntax generated by Rust)
    // This test checks that the compiler can handle many variable declarations in one function.
    // The generated code is valid doolang: fn main() { let x0 = 0; let x1 = 1; ... let x99 = 99; }
    // =====================
    #[test]
    fn test_mir_for_many_variables() {
        let mut input = String::from("fn main() {");
        for i in 0..100 {
            input.push_str(&format!("let x{} = {};", i, i));
        }
        input.push_str("}");
        let result = build_mir(&input);
        assert!(result.is_ok());
    }

    // =====================
    // Control Flow
    // =====================
    #[test]
    fn test_mir_for_if_else() {
        let input = r#"
            fn main() {
                if true {
                    let x = 1;
                } else {
                    let y = 2;
                }
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_nested_if() {
        let input = r#"
            fn main() {
                if true {
                    if false {
                        let x = 1;
                    }
                }
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_for_loop() {
        let input = r#"
            fn main() {
                for i in 0..10 {
                    let x = i;
                }
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_nested_loops() {
        let input = r#"
            fn main() {
                for i in 0..5 {
                    for j in 0..5 {
                        let z = i + j;
                    }
                }
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_nested_loops_and_if() {
        let input = r#"
            fn main() {
                let mut total = 0;
                for i in 0..3 {
                    for j in 0..3 {
                        if i > 0 && j > 0 {
                            total += 1;
                        }
                    }
                }
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_nested_for_loops_mir() {
        let input = r#"
            fn main() {
                for i in 0..3 {
                    for j in 0..2 {
                        print(i + j);
                    }
                }
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_break_continue_nested_loops_mir() {
        let input = r#"
            fn main() {
                for i in 0..5 {
                    for j in 0..5 {
                        if j == 2 { break; }
                        if i == 3 { continue; }
                    }
                }
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    // =====================
    // Array Tests
    // =====================
    #[test]
    fn test_mir_for_array_literal() {
        let input = r#"
            fn main() {
                let arr = [1, 2, 3, 4];
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_empty_array() {
        let input = r#"
            fn main() {
                let arr: [Int] = [];
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    // =====================
    // Stress Test: Large Array Literal (doolang syntax generated by Rust)
    // This test checks that the compiler can handle a large array literal.
    // The generated code is valid doolang: fn main() { let arr = [0, 1, ..., 999]; }
    // =====================
    #[test]
    fn test_mir_for_large_array() {
        let arr = (0..1000)
            .map(|i| i.to_string())
            .collect::<Vec<_>>()
            .join(", ");
        let input = format!("fn main() {{ let arr = [{}]; }}", arr);
        let result = build_mir(&input);
        assert!(result.is_ok());
    }

    // =====================
    // Map Tests
    // =====================
    #[test]
    fn test_mir_for_map_literal() {
        let input = r#"
            fn main() {
                let m = {"a": 1, "b": 2};
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_empty_map() {
        let input = r#"
            fn main() {
                let m: {Str: Int} = {};
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    // =====================
    // Array Element Access
    // =====================
    #[test]
    fn test_mir_array_access_basic() {
        let input = r#"
            fn main() {
                let arr = [10, 20, 30];
                let x = arr[0];
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok(), "MIR should build for basic array access");
        let mir = result.unwrap();
        let main_fn = mir
            .program
            .functions
            .iter()
            .find(|f| f.name == "main")
            .unwrap();
        let found_array_get = main_fn.blocks.iter().any(|block| {
            block
                .instrs
                .iter()
                .any(|instr| matches!(instr, crate::mir::MirInstr::ArrayGet { .. }))
        });
        assert!(found_array_get, "MIR should contain ArrayGet for arr[0]");
    }

    #[test]
    fn test_mir_array_access_in_loop() {
        let input = r#"
            fn main() {
                let arr = [5, 10, 15, 20];
                for i in 0..4 {
                    let x = arr[i];
                }
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok(), "MIR should build for array access in loop");
        let mir = result.unwrap();
        let main_fn = mir
            .program
            .functions
            .iter()
            .find(|f| f.name == "main")
            .unwrap();
        let found_array_get = main_fn.blocks.iter().any(|block| {
            block
                .instrs
                .iter()
                .any(|instr| matches!(instr, crate::mir::MirInstr::ArrayGet { .. }))
        });
        assert!(found_array_get, "MIR should contain ArrayGet for arr[i]");
    }

    // Invalid array element access
    #[test]
    fn test_mir_array_access_invalid_empty_index() {
        let input = r#"
            fn main() {
                let arr = [1,2,3];
                let x = arr[];
            }
        "#;
        let result = build_mir(input);
        assert!(
            result.is_err(),
            "MIR should not build for arr[] (empty index)"
        );
    }

    #[test]
    fn test_mir_array_access_invalid_string_index() {
        let input = r#"
            fn main() {
                let arr = [1,2,3];
                let x = arr["bad"];
            }
        "#;
        let result = build_mir(input);
        assert!(
            result.is_err(),
            "MIR should not build for arr[\"bad\"] (string index)"
        );
    }

    #[test]
    fn test_mir_array_access_invalid_float_index() {
        let input = r#"
            fn main() {
                let arr = [1,2,3];
                let x = arr[1.5];
            }
        "#;
        let result = build_mir(input);
        assert!(
            result.is_err(),
            "MIR should not build for arr[1.5] (float index)"
        );
    }

    // =====================
    // Assignment Operators & Compound Assignment
    // =====================
    #[test]
    fn test_mir_for_assignment_operators() {
        let input = r#"
            fn main() {
                let mut x = 1;
                x += 2;
                x -= 1;
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_compound_assignment_patterns() {
        let input = r#"
            fn main() {
                let mut x = 10;
                x += 5;
                x -= 3;
                x *= 2;
                x /= 4;
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_compound_assignment_to_undeclared() {
        let input = r#"
            fn main() {
                y += 1;
            }
        "#;
        let result = build_mir(input);
        assert!(
            result.is_err(),
            "Should fail: compound assignment to undeclared variable"
        );
    }

    #[test]
    fn test_mir_for_compound_assignment_to_immutable() {
        let input = r#"
            fn main() {
                let x = 1;
                x += 2;
            }
        "#;
        let result = build_mir(input);
        assert!(
            result.is_err(),
            "Should fail: compound assignment to immutable variable"
        );
    }

    #[test]
    fn test_mir_for_compound_assignment_with_wrong_type() {
        let input = r#"
            fn main() {
                let mut s = "hello";
                s += 1;
            }
        "#;
        let result = build_mir(input);
        assert!(
            result.is_err(),
            "Should fail: compound assignment with wrong type"
        );
    }

    // =====================
    // Boolean Logic & Comparison
    // =====================
    #[test]
    fn test_mir_for_boolean_operations() {
        let input = r#"
            fn main() {
                let b = true && false || true;
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_comparison_operations() {
        let input = r#"
            fn main() {
                let b = 1 < 2 && 3 >= 2;
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_boolean_logic_in_if_and_loop() {
        let input = r#"
            fn main() {
                for i in 0..3 {
                    if i > 0 && i < 2 {
                        print("yes");
                    }
                }
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mir_for_boolean_logic_with_non_bool() {
        let input = r#"
            fn main() {
                let b = 1 && 2;
            }
        "#;
        let result = build_mir(input);
        assert!(
            result.is_err(),
            "Should fail: boolean logic with non-bool operands"
        );
    }

    // =====================
    // String Operations
    // =====================
    #[test]
    fn test_mir_for_string_operations() {
        let input = r#"
            fn main() {
                let s = "hello" + "world";
            }
        "#;
        let result = build_mir(input);
        assert!(result.is_ok());
    }

    // =====================
    // Miscellaneous/Invalid/Edge Cases
    // =====================
    #[test]
    fn test_mir_for_invalid_syntax() {
        let input = "fn main( { let x = ; }";
        let result = build_mir(input);
        assert!(result.is_err());
    }

    #[test]
    fn test_mir_for_invalid_type() {
        let input = "fn main() { let x: Foo = 1; }";
        let result = build_mir(input);
        assert!(result.is_err());
    }

    #[test]
    fn test_mir_for_invalid_assignment() {
        let input = "fn main() { x = 1; }";
        let result = build_mir(input);
        assert!(result.is_err());
    }

    #[test]
    fn test_mir_for_invalid_function_call() {
        let input = "fn main() { foo(1, 2); }";
        let result = build_mir(input);
        assert!(result.is_err());
    }

    #[test]
    fn test_mir_for_invalid_array_access_empty_index() {
        let input = "fn main() { let arr = [1,2,3]; let x = arr[]; }";
        let result = build_mir(input);
        assert!(result.is_err(), "Should fail for arr[] (empty index)");
    }

    #[test]
    fn test_mir_for_invalid_array_access_string_index() {
        let input = "fn main() { let arr = [1,2,3]; let x = arr[\"bad\"]; }";
        let result = build_mir(input);
        assert!(
            result.is_err(),
            "Should fail for arr[\"bad\"] (string index)"
        );
    }

    #[test]
    fn test_mir_for_invalid_array_access_float_index() {
        let input = "fn main() { let arr = [1,2,3]; let x = arr[1.5]; }";
        let result = build_mir(input);
        assert!(result.is_err(), "Should fail for arr[1.5] (float index)");
    }

    #[test]
    fn test_mir_for_invalid_map_access_empty_key() {
        let input = "fn main() { let m = {\"a\": 1}; let x = m[]; }";
        let result = build_mir(input);
        assert!(result.is_err(), "Should fail for m[] (empty key)");
    }

    #[test]
    fn test_mir_for_invalid_map_access_unclosed_bracket() {
        let input = "fn main() { let m = {\"a\": 1}; let x = m[\"key\"; }";
        let result = build_mir(input);
        assert!(
            result.is_err(),
            "Should fail for m[\"key\" (unclosed bracket)"
        );
    }

    #[test]
    fn test_immutable_assignment_mir() {
        let input = "fn main() { let x = 5; x = 10; }";
        let result = build_mir(input);
        assert!(
            result.is_err(),
            "Should fail on assignment to immutable variable"
        );
    }

    #[test]
    fn test_if_condition_not_bool_mir() {
        let input = "fn main() { if 42 { print(1); } }";
        let result = build_mir(input);
        assert!(result.is_err(), "Should fail if condition is not bool");
    }
}
